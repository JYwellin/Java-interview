# 1.面向对象可以解释下吗？都有哪些特性？
答：面向对象是一种思想，可以将复杂问题简单化，让我们从执行者变为了指挥者。面向对象的三大特性为：封装，继承与多态。

封装：将事物封装成一个类，减少耦合，隐藏细节。保留特定的接口与外界联系，当接口内部发生改变时，不会影响外部调用方。

继承：从一个已知的类中派生出一个新的类，新类可以拥有已知类的行为和属性，并且可以通过覆盖/重写来增强已知类的能力。

多态：多态的本质就是一个程序中存在多个同名的不同方法，主要通过三种方式来实现：

- 通过子类对父类的覆盖来实现

- 通过在一个类中对方法的重载来实现

- 通过将子类对象作为父类对象使用来实现


Java中类的初始化顺序：

- 初始化父类中的静态成员变量和静态代码块
- 初始化子类中的静态成员变量和静态代码块
- 初始化父类中的普通成员变量和代码块，再执行父类的构造方法
- 初始化子类中的普通成员变量和代码块，再执行子类的构造方法

# 2.JDK，JRE和JVM的区别与联系有哪些？
三者的基本概念可以概括如下：

JDK（Java Development Kit）是一个开发工具包，是Java开发环境的核心组件，并且提供编译、调试和运行一个Java程序所需要的所有工具，可执行文件和二进制文件，是一个平台特定的软件

JRE（Java Runtime Environment）是指Java运行时环境，是JVM的实现，提供了运行Java程序的平台。JRE包含了JVM，但是不包含Java编译器/调试器之类的开发工具

JVM（Java Virtual Machine）是指Java虚拟机，当我们运行一个程序时，JVM负责将字节码转换为特定机器代码，JVM提供了内存管理/垃圾回收和安全机制等

## 区别与联系：

JDK是开发工具包，用来开发Java程序，而JRE是Java的运行时环境

JDK和JRE中都包含了JVM

JVM是Java编程的核心，独立于硬件和操作系统，具有平台无关性，而这也是Java程序可以一次编写，多处执行的原因

## Java语言的平台无关性是如何实现的？

JVM屏蔽了操作系统和底层硬件的差异

Java面向JVM编程，先编译生成字节码文件，然后交给JVM解释成机器码执行

通过规定基本数据类型的取值范围和行为

## Java语言是编译型还是解释型语言？

Java的执行经历了编译和解释的过程，是一种先编译，后解释执行的语言，不可以单纯归到编译性或者解释性语言的类别中。

# 3.抽象类和接口有什么区别？

- 抽象类中可以没有抽象方法，也可以抽象方法和非抽象方法共存
- 接口中的方法在JDK8之前只能是抽象的，JDK8版本开始提供了接口中方法的default实现
- 抽象类和类一样是单继承的；接口可以实现多个父接口
- 抽象类中可以存在普通的成员变量；接口中的变量必须是static final类型的，必须被初始化，接口中只有常量，没有变量

## 抽象类和接口应该如何选择？分别在什么情况下使用呢？

根据抽象类和接口的不同之处，当我们仅仅需要定义一些抽象方法而不需要其余额外的具体方法或者变量的时候，我们可以使用接口。反之，则需要使用抽象类，因为抽象类中可以有非抽象方法和变量。

## 那么JDK8中为什么会出现默认方法呢？

使用接口，使得我们可以面向抽象编程，但是其有一个缺点就是当接口中有改动的时候，需要修改所有的实现类。在JDK8中，为了给已经存在的接口增加新的方法并且不影响已有的实现，所以引入了接口中的默认方法实现。

# 4.Java中的8种基本数据类型及其取值范围

略

# 5. Java中的元注解有哪些？ 
Java中提供了4个元注解，元注解的作用是负责注解其它注解。

- @Target：描述注解能够作用的位置
				* ElementType取值：
					* TYPE：可以作用于类上
					* METHOD：可以作用于方法上
					* FIELD：可以作用于成员变量上
- @Retention：描述注解被保留的阶段
				* @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到
- @Documented：描述注解是否被抽取到api文档中
- @Inherited：描述注解是否被子类继承

# 6.说说Java中反射机制？
反射机制是指在运行中，对于任意一个类，都能够知道这个类的所有属性和方法。对于任意一个对象，都能够调用它的任意一个方法和属性。即动态获取信息和动态调用对象方法的功能称为反射机制。

## 反射机制的作用：
在运行时判断任意一个对象所属的类

在运行时构造一个类的对象

在运行时判断任意一个类所具有的成员变量和方法

在运行时调用任意一个对象的方法，生成动态代理

## 与反射相关的类：
Class：表示类，用于获取类的相关信息

Field：表示成员变量，用于获取实例变量和静态变量等

Method：表示方法，用于获取类中的方法参数和方法类型等

Constructor：表示构造器，用于获取构造器的相关参数和类型等

# 7.Java中的Exception和Error有什么区别？
Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： Error 和 Exception。

Exception和Error的主要区别可以概括如下。

Exception是程序正常运行中预料到可能会出现的错误，并且应该被捕获并进行相应的处理，是一种异常现象

Error是正常情况下不可能发生的错误，Error会导致JVM处于一种不可恢复的状态，不需要捕获处理，比如说OutOfMemoryError

Exception又分为了运行时异常和编译时异常。

编译时异常（受检异常）表示当前调用的方法体内部抛出了一个异常，所以编译器检测到这段代码在运行时可能会出异常，所以要求我们必须对异常进行相应的处理，可以捕获异常或者抛给上层调用方。

运行时异常（非受检异常）表示在运行时出现的异常，常见的运行时异常包括：空指针异常，数组越界异常，数字转换异常以及算术异常等。

前边说到了异常Exception应该被捕获，我们可以使用try – catch – finally 来处理异常，并且使得程序恢复正常。

## 那么我们捕获异常应该遵循哪些原则呢？
尽可能捕获比较详细的异常，而不是使用Exception一起捕获。

当本模块不知道捕获之后该怎么处理异常时，可以将其抛给上层模块。上层模块拥有更多的业务逻辑，可以进行更好的处理。

捕获异常后至少应该有日志记录，方便之后的排查。

不要使用一个很大的try – catch包住整段代码，不利于问题的排查。

# 8.JIT编译器有了解吗？
JIT编译器全名叫Just In Time Compile 也就是即时编译器，把经常运行的代码作为"热点代码"编译成与本地平台相关的机器码，并进行各种层次的优化。JIT编译除了具有缓存的功能外，还会对代码做各种优化，包括逃逸分析、锁消除、 锁膨胀、方法内联、空值检查消除、类型检测消除以及公共子表达式消除等。

# 9.String,StringBuffer与StringBuilder的区别
和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。

StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。

由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。

#9.Java中的泛型的理解
泛型就是将所操作的数据类型作为参数的一种语法, 可以在类或方法中预支地使用未知的类型。

## 泛型的作用
- 使用泛型能写出更加灵活通用的代码
- 泛型将代码安全性检查提前到编译期
-- 将运行时期的ClassCastException，转移到了编译时期变成了编译失败
- - 泛型能够省去类型强制转换

#10.equals和hashCode方法的关系？
## object的常用方法
clone、equals、hashcode、toString、getclass、finalize

notify、notifyAll、wait

##原则
1.同一个对象（没有发生过修改）无论何时调用hashCode()得到的返回值必须一样。
如果一个key对象在put的时候调用hashCode()决定了存放的位置，而在get的时候调用hashCode()得到了不一样的返回值，这个值映射到了一个和原来不一样的地方，那么肯定就找不到原来那个键值对了。

2.hashCode()的返回值相等的对象不一定相等，通过hashCode()和equals()必须能唯一确定一个对象。不相等的对象的hashCode()的结果可以相等。hashCode()在注意关注碰撞问题的时候，也要关注生成速度问题，完美hash不现实。

3.一旦重写了equals()函数（重写equals的时候还要注意要满足自反性、对称性、传递性、一致性），就必须重写hashCode()函数。而且hashCode()的生成哈希值的依据应该是equals()中用来比较是否相等的字段。

如果两个由equals()规定相等的对象生成的hashCode不等，对于hashMap来说，他们很可能分别映射到不同位置，没有调用equals()比较是否相等的机会，两个实际上相等的对象可能被插入不同位置，出现错误。其他一些基于哈希方法的集合类可能也会有这个问题

# 11.Java和C++的区别有哪些？
- Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。
- Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。
- Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。
- Java 支持自动垃圾回收，而 C++ 需要手动回收。
- Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。
- Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。
- Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。

#12.Java序列化与反序列化的过程
将对象转换为字节序列存储到硬盘上的过程叫做对象的序列化；反序列化则是把硬盘上的字节序列读取恢复成一个对象的过程

#静态与非静态的区别？
#Java中equals方法和==的区别？
